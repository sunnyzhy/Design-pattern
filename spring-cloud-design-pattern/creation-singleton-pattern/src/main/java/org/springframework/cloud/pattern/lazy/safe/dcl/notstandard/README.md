# 懒汉模式（双重检查锁 - 普通实现）

## 优点

双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题。

## 缺点

此示例的双重检测锁模式看上去完美无缺，其实存在问题，在多线程的情况下，可能会出现空指针，因为 JVM 在实例化对象的时候会进行优化和指令重排序操作。指令重排示例:

```java
private Singleton() {
1   int x = 10;
2   int y = 30;
3   Object o = new Object();
}
```

构造函数 ```Singleton()``` 里编写的顺序是 ```1、2、3```，JVM 会对它进行指令重排序，最终的执行顺序可能是 ```3、1、2```，也可能是 ```2、3、1```，不管是哪种执行顺序，JVM 最后都会保证所以实例都完成实例化。如果构造函数中操作比较多，为了提升效率，JVM 会在构造函数里面的属性未全部完成实例化时就返回对象。

双重检测锁出现空指针的原因就出在这里，当某个线程获取锁进行实例化时，其他线程就直接获取实例使用，由于 JVM 指令重排序的原因，其他线程获取的对象也许不是一个完整的对象，所以在使用实例的时候就会出现空指针的异常问题。
